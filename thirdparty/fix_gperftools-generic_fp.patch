From f74212f40055d78d54cadf473907c7f0fbe1b6d1 Mon Sep 17 00:00:00 2001
From: Yikai Zhao <yikai@z1k.dev>
Date: Mon, 25 Sep 2023 19:04:23 +0800
Subject: [PATCH] generic_fp stacktrace: check frame size threshold for initial
 frame

Fix result overflow in generic_fp stacktrace

In the 'with ucontext' case, the `skip_count` would be reset to 0, and
`max_depth` should not be modified. Otherwise the result array would overflow.
---
 src/stacktrace_generic_fp-inl.h | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/src/stacktrace_generic_fp-inl.h b/src/stacktrace_generic_fp-inl.h
index aa32bc5..91fedef 100644
--- a/src/stacktrace_generic_fp-inl.h
+++ b/src/stacktrace_generic_fp-inl.h
@@ -123,8 +123,6 @@ int capture(void **result, int max_depth, int skip_count,
             int *sizes) {
   int i = 0;
 
-  max_depth += skip_count;
-
   if (initial_pc != nullptr) {
     // This is 'with ucontext' case. We take first pc from ucontext
     // and then skip_count is ignored as we assume that caller only
@@ -137,6 +135,8 @@ int capture(void **result, int max_depth, int skip_count,
     i++;
   }
 
+  max_depth += skip_count;
+
   constexpr uintptr_t kTooSmallAddr = 16 << 10;
   constexpr uintptr_t kFrameSizeThreshold = 128 << 10;
 
@@ -156,6 +156,7 @@ int capture(void **result, int max_depth, int skip_count,
   constexpr uintptr_t kAlignment = 16;
 #endif
 
+  uintptr_t current_frame_addr = reinterpret_cast<uintptr_t>(__builtin_frame_address(0));
   uintptr_t initial_frame_addr = reinterpret_cast<uintptr_t>(initial_frame);
   if (((initial_frame_addr + sizeof(frame)) & (kAlignment - 1)) != 0) {
     return i;
@@ -163,11 +164,14 @@ int capture(void **result, int max_depth, int skip_count,
   if (initial_frame_addr < kTooSmallAddr) {
     return i;
   }
+  if (initial_frame_addr - current_frame_addr > kFrameSizeThreshold) {
+    return i;
+  }
 
   // Note, we assume here that this functions frame pointer is not
   // bogus. Which is true if this code is built with
   // -fno-omit-frame-pointer.
-  frame* prev_f = reinterpret_cast<frame*>(__builtin_frame_address(0));
+  frame* prev_f = reinterpret_cast<frame*>(current_frame_addr);
   frame *f = adjust_fp(reinterpret_cast<frame*>(initial_frame));
 
   while (i < max_depth) {
-- 
2.42.1

